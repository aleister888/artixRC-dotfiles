#!/bin/sh

REPO_URL="https://github.com/aleister888/artix-installer"

# Alias para herramientas comunes
alias wget='wget --hsts-file="$XDG_CONFIG_HOME"/wget-hsts'
alias gpg2='gpg2 --homedir "$XDG_DATA_HOME"/gnupg'

# Alias de comandos básicos
alias v='nvim'
alias c='/bin/clear'
alias mi='sudo make install'
alias cp='cp -iv'
alias cat='bat -p --tabs 8'
alias ls='eza -lagX --time-style iso --group-directories-first --smart-group'
alias grep='grep --color=auto'

# Alias para moverse rápidamente entre directorios
alias ..='cd ..'
alias ...='cd ../..'

# Actualizar el sistema
alias update='
	yay -Syuu --answerclean --answerdiff --removemake \
		--ignore i3lock-fancy-git --ignore eww-git
'

# Herramientas
alias xdotool_table='xmodmap -pk'
alias du='BLOCKSIZE=1073741824 du -s * | sort -rnk 1'
alias grub-update='sudo grub-mkconfig -o /boot/grub/grub.cfg'

# Alias para encontrar enlaces simbólicos rotos y archivos no reclamados
alias brokenlink='find / -xtype l -print 2>/dev/null'
alias unownedfiles='sudo find / ! -name "/mnt/*" -nogroup -nouser -print 2>/dev/null'
alias lostfiles='sudo lostfiles | grep -iv "Theme\|opt\|Font"'

# Detectar que paquetes del AUR necesitan recompilarse
alias rebuild-detector="checkrebuild -v"

# Limpiar dependencias innecesarias
cleanup() {
	packages=$(yay -Qdtq)
	if [ -n "$packages" ]; then
		# shellcheck disable=SC2086
		yay -Rcns $packages
	fi
}

deepcleanup() {
	pacman -Qqd 2>/dev/null |
		pacman -Rsu --print - 2>/dev/null |
		grep - | sed 's/-[0-9].*//g' >/tmp/pacman_unneeded
	packages=$(grep -v ca-certificates /tmp/pacman_unneeded)
	if [ -n "$packages" ]; then
		# shellcheck disable=SC2086
		sudo pacman -Rcns $packages
	fi
}

# Función para reinstalar todos los paquetes
reinstall() {
	# shellcheck disable=SC2046
	yay -S $(pacman -Qq | grep -v "$(pacman -Qqm)")
}

# Función para restaurar los paquetes
# instalados explícitamente como tales
reexplicit() {
	for pack in $(yay -Qq); do
		if grep -E "\[ALPM\] installed" /var/log/pacman.log |
			grep "$pack" >/dev/null 2>&1; then
			sudo pacman -D --asexplicit "$pack"
		fi
	done
}

# Recuperación en caso de paquetes rotos
recoverypacman() {
	yay "$@" \
		--logfile /dev/null \
		--noscriptlet \
		--dbonly \
		--overwrite "*" \
		--nodeps \
		--needed
}

# Imprimir instancia, clase y título de la ventana seleccionada
xprop_wininfo() {
	xprop | awk '
	/^WM_CLASS/ {
		sub(/^.* = /, "instance:");
		sub(/,/, "\nclass:");
		print
	}
	/^WM_NAME/ {
		sub(/^.* = /, "title:");
		print
	}
	'
}

# Borrar entornos de un código laTeX
desencapsular() {
	tag="$1"
	shift
	perl -pe "s/\\\\$tag\\{([^{}]*(?:\\{$tag\\}[^{}]*)*)\\}/\$1/g" "$@"
}

# Grabar la pantalla
screenrecord() {
	# Verificar si se proporcionó un archivo de salida
	[ -z "$1" ] && {
		echo "Se debe dar como argumento el archivo de salida" >&2
		return 1
	}

	# Detectar resolución de pantalla
	RESOLUTION=$(xrandr | grep '\*' | awk '{print $1}')

	# Definir dispositivos de audio
	MICROPHONE=$(pactl list sources | grep -oP "Name: \K.*input.*" | head -n 1)
	APPLICATIONS=$(pactl list sources | grep -oP "Name: \K.*output.*" | head -n 1)

	ffmpeg \
		-video_size "$RESOLUTION" \
		-framerate 30 \
		-f x11grab -i :0.0 \
		-f pulse -i "$MICROPHONE" \
		-f pulse -i "$APPLICATIONS" \
		-filter_complex "[1:a][2:a]amerge=inputs=2[audio]" \
		-map 0:v -map "[audio]" \
		-c:v libx264 -preset ultrafast -crf 18 \
		-c:a aac -b:a 192k \
		"$1"
}

yabridgectl_dirs() {
	[ -d "$WINEPREFIX/drive_c/Program Files/Common Files" ] &&
		yabridgectl add "$WINEPREFIX/drive_c/Program Files/Common Files"
	[ -d "$WINEPREFIX/drive_c/Program Files/Steinberg" ] &&
		yabridgectl add "$WINEPREFIX/drive_c/Program Files/Steinberg"
}

push() {
	if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
		git add . &&
			git commit &&
			git push
	else
		echo "No estás dentro de ningún repositorio"
	fi
}

# Alias para encontrar archivos pac de pacman
pac() {
	# Buscar archivos .pacnew y .pacsave
	sudo find /etc \( -name "*.pacnew" -o -name "*.pacsave" \) 2>/dev/null | while read -r file; do
		# Obtener el nombre del archivo original
		original_file="${file%.pacnew}"
		original_file="${original_file%.pacsave}"

		# Mostrar encabezado
		echo "##$(printf '#%.0s' $(seq 1 ${#original_file}))##"
		echo "# $original_file #"
		echo "##$(printf '#%.0s' $(seq 1 ${#original_file}))##"

		# Mostrar diferencias y limitar la salida
		diff -d "$file" "$original_file" | head -n 20
	done
}

whip_msg() {
	whiptail --backtitle "$REPO_URL" --title "$1" --msgbox "$2" 10 60
}

whip_yes() {
	whiptail --backtitle "$REPO_URL" --title "$1" --yesno "$2" 10 60
}

whip_menu() {
	TITLE="$1"
	MENU="$2"
	shift 2
	# shellcheck disable=SC2068
	whiptail --backtitle "$REPO_URL" \
		--title "$TITLE" --menu "$MENU" 15 60 5 $@ 3>&1 1>&2 2>&3
}

whip_input() {
	TITLE=$1
	INPUTBOX=$2
	whiptail --backtitle "$REPO_URL" \
		--title "$TITLE" --inputbox "$INPUTBOX" \
		10 60 3>&1 1>&2 2>&3
}

# Función para validar la indentación de un archivo
indent_check() {
	# Validar que el número de espacios es un entero
	if ! print -r -- "$1" | grep -qE '^[0-9]+$' || [ ! -f "$2" ]; then
		echo "Uso: indent_check <nº espacios> <archivo>"
		return 1
	fi

	nEspacios=$1
	archivo=$2

	awk -v n="$nEspacios" '
	{
		match($0, /^[ ]+/)
		if (RSTART == 1) {
			spaces = RLENGTH
			if (spaces % n != 0) print NR, "Indentación incorrecta:", spaces, "espacios ->", $0
		}
	}' "$archivo"
}

# Función para ver el historial de commits
view_commits() {
	git log --oneline --graph --decorate | nvim -
}

# Función para hacer commit y push
commit_and_push() {
	git add .
	git commit || {
		whip_msg "Error" "El commit no se completó correctamente."
		return 1
	}
	if git push; then
		whip_msg "Éxito" "Commit y push realizados con éxito."
	else
		whip_msg "Error" "El push no se completó correctamente."
	fi
}

# Función para restaurar con git reset --hard origin
reset_hard() {
	if whip_yes \
		"Restaurar" \
		"¿Estás seguro? Se perderán los cambios locales."; then
		git reset --hard origin
	else
		whip_msg "Cancelado" "Operación cancelada."
	fi
}

# Función para hacer reset a un commit específico
reset_to_commit() {
	# Usamos un inputbox para pedir el hash del commit al usuario
	commit_hash=$(whip_input "Introducir hash del commit" "Por favor, introduce el hash del commit:")

	# Verificar si el hash no está vacío
	if [ -z "$commit_hash" ]; then
		whip_msg "Error" "No se introdujo un hash de commit."
		return 1
	fi

	# Confirmar antes de hacer el reset
	if whip_yes "Restaurar commit" "¿Estás seguro de que quieres retroceder al commit $commit_hash? Se perderán los cambios después de este commit."; then
		# Realizar el reset al commit seleccionado
		git reset --hard "$commit_hash"
		# Hacer push forzado al repositorio remoto
		if git push origin HEAD --force; then
			whip_msg "Éxito" "Repositorio remoto actualizado con éxito."
		else
			whip_msg "Error" "El push forzado no se completó correctamente."
		fi
	else
		whip_msg "Cancelado" "Operación cancelada."
	fi
}

githelp() {
	# Comprobar si estamos en un directorio de Git
	if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
		return 1
	fi

	# Menú principal
	while true; do
		choice=$(
			whip_menu \
				"GitHub" "Selecciona una opción:" \
				"1" "Ver historial de commits" \
				"2" "Hacer commit y push" \
				"3" "Restaurar con git reset --hard origin" \
				"4" "Restaurar a un commit específico" \
				"5" "Cambiar el mensaje del último commit" \
				"6" "Salir"
		)

		case $choice in
		1) view_commits ;;
		2) commit_and_push ;;
		3) reset_hard ;;
		4) reset_to_commit ;;
		5)
			git commit --amend &&
				git push origin +HEAD
			;;
		6)
			whip_yes "Salir" \
				"¿Estás seguro de que quieres salir?" &&
				break
			;;
		*) break ;;
		esac
	done
}

code_format() {
	# Directorio donde se encuentran los scripts
	directorio=$1

	# Si no se pasó un directorio, usamos el directorio actual
	if [ -z "$directorio" ]; then
		directorio="."
	fi

	# Buscar todos los archivos en el directorio
	find "$directorio" -type d -name ".git" -prune -o -type f | while read -r archivo; do
		# Obtener el tipo MIME del archivo
		mime_type=$(xdg-mime query filetype "$archivo")

		# Si el tipo MIME es 'application/x-shellscript', formatear el archivo
		case "$mime_type" in
		application/x-shellscript)
			shfmt -w "$archivo" &&
				echo "Formateado: $archivo"
			;;
		text/x-java)
			astyle --style=allman --indent=spaces=4 -n "$archivo" &&
				echo "Formateado: $archivo"
			;;
		text/x-tex)
			latexindent -w "$archivo" >/dev/null 2>&1 &&
				echo "Formateado: $archivo"

			# Extraer el nombre base sin extensión
			nombre_base=$(echo "$archivo" | sed 's/\.[^.]*$//')

			# Mover archivos .bak generados por latexindent
			for bak_archivo in "${nombre_base}".bak*; do
				if [ -f "$bak_archivo" ]; then
					mv "$bak_archivo" /tmp/
				fi
			done
			;;
		esac
	done

	# Mensaje final
	echo "Todos los archivos han sido formateados."
}
